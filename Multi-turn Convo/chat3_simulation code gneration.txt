Thanks. I think we need a Python code to realize it, can you give me a sample code?
ChatGPT
Creating a full code for a DQN agent using Meep for simulating PCSELs is a complex task that involves many components. However, I can certainly provide a simplified version of a DQN agent to give you an idea of the basic structure and how it would interact with the environment. This is a rather simplistic DQN implementation in Python using PyTorch:

python
Copy code
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import random
from collections import deque

class Net(nn.Module):
    def __init__(self, state_size, action_size):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(state_size, 50)
        self.fc2 = nn.Linear(50, action_size)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        return self.fc2(x)

class DQN:
    def __init__(self, state_size, action_size):
        self.state_size = state_size
        self.action_size = action_size
        self.memory = deque(maxlen=2000)
        self.gamma = 0.95  # discount factor
        self.epsilon = 1.0  # exploration rate
        self.epsilon_min = 0.01
        self.epsilon_decay = 0.995
        self.learning_rate = 0.001
        self.model = Net(state_size, action_size)
        self.optimizer = optim.Adam(self.model.parameters(), lr=self.learning_rate)
        self.criterion = nn.MSELoss()

    def remember(self, state, action, reward, next_state, done):
        self.memory.append((state, action, reward, next_state, done))

    def act(self, state):
        if np.random.rand() <= self.epsilon:
            return random.randrange(self.action_size)
        act_values = self.model(torch.FloatTensor(state))
        return torch.argmax(act_values).item()

    def replay(self, batch_size):
        minibatch = random.sample(self.memory, batch_size)
        for state, action, reward, next_state, done in minibatch:
            target = reward
            if not done:
                target = (reward + self.gamma * np.amax(self.model(torch.FloatTensor(next_state)).detach().numpy()))
            target_f = self.model(torch.FloatTensor(state))
            target_f[action] = target
            self.optimizer.zero_grad()
            loss = self.criterion(self.model(torch.FloatTensor(state)), target_f)
            loss.backward()
            self.optimizer.step()
        if self.epsilon > self.epsilon_min:
            self.epsilon *= self.epsilon_decay
Note that this code is only a starting point and might need to be adjusted according to your specific requirements. You'd need to integrate it with your simulation environment using Meep, define your state and action spaces, implement the correct reward function, and set the appropriate hyperparameters.

This implementation also does not include advanced DQN features like experience replay, target networks, or double DQN, which can be crucial for the stability and performance of your DQN agent. The details of how to set up your Meep simulations, interact with the simulation environment, and how to process and represent your PCSEL designs as state representations for the DQN are also beyond the scope of this simplified example.

Please take this as a basic example, you should definitely look into more sophisticated RL libraries like Stable Baselines3 or RLlib, which offer fully-featured DQN implementations with many enhancements and utility functions for training and evaluating RL agents.





User

3 / 3

Thanks a lot. As you mentioned, we also need a simulation environment using Meep. Can you give me a sample for our 3D PCSEL simulation ?
ChatGPT
Creating a simulation environment for 3D Photonic Crystal Surface-Emitting Lasers (PCSELs) using Meep requires knowledge of the exact parameters and design of the photonic crystal and laser system. However, I can provide a simplified Python script that shows how to setup a 3D structure in Meep. This won't be an actual PCSEL but it should provide a starting point for your own simulations:

python
Copy code
import meep as mp

# Define the 3D cell size
cell_size = mp.Vector3(10, 10, 10)

# Define the 3D lattice constant
lattice_constant = 1.0

# Define the photonic crystal's structure
structure = [mp.Block(mp.Vector3(mp.inf, lattice_constant, mp.inf),
                      center=mp.Vector3(),
                      material=mp.Medium(epsilon=12))]

# Define the 3D geometry
geometry = [mp.Sphere(radius=0.2, material=mp.Medium(epsilon=2))]

# Define the 3D sources
sources = [mp.Source(mp.ContinuousSource(wavelength=2*(11**0.5), width=20),
                     component=mp.Ez,
                     center=mp.Vector3())]

# Define the PML layers
pml_layers = [mp.PML(1.0)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Run the simulation
sim.run(until=200)
This is a very simple script that creates a simulation with a single spherical object in the middle of the simulation cell. The cell has periodic boundary conditions on the y-axis, creating a 1D photonic crystal.

Please remember that this is just a simplified example. In an actual PCSEL, you would need to define a 2D or 3D lattice of holes in a slab of semiconductor material. The exact positions, sizes, and materials of these holes, as well as the slab thickness, would need to be defined based on your PCSEL design. Furthermore, you would need to add a source to represent the laser pump, and probably also define monitors to measure the emitted light.

The documentation for Meep is quite extensive and includes many examples, and I highly recommend going through it to understand how to set up more complex simulations: https://meep.readthedocs.io/en/latest/





User
Your code helps a lot. That us make the requirement more specific. Our 3D PCSEL should be five layers. And from top to bottom they are n-substrate layer, n-cladding layer, active layer, photonic crystal layer, p-cladding layer, initializing their thickness 0.2, 0.3, 0.5, 0.3, 0.3 respectively. And the initial reflective index of both n-cladding layer and p-cladding layer are both 3.2. The initial reflective index of n-substrate layer and   active layer is 3.0, 3.4 respectively. Considering these additions, help me modify the previous Meep code.
ChatGPT
Sure, let's create a simulation for your layered PCSEL. I'll use blocks in Meep to represent each of the layers. Keep in mind, for the photonic crystal layer, we only define the base material with a refractive index. Constructing an actual photonic crystal lattice structure would require additional definitions of holes or inclusions with different refractive indices, which I will not include in this basic example.

Here is a simplified version:

python
Copy code
import meep as mp

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the 3D cell size
cell_size = mp.Vector3(10, 10, z_total)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(mp.inf, mp.inf, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the PML layers
pml_layers = [mp.PML(1.0)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    resolution=10)

# Run the simulation
sim.run(until=200)
This script creates a layered structure according to your specifications. Each layer is a block that extends infinitely in the x and y directions and has the specified thickness in the z direction.

Keep in mind, this is a very simplified representation of a PCSEL. For an actual device, the photonic crystal layer would need to be defined with a periodic lattice of holes or inclusions, and the active layer would need to have a gain medium to model the lasing process. In addition, you would need to add a source to represent the pump light, and detectors to measure the output. These details are beyond the scope of this basic example.

The Meep documentation is a great resource for understanding how to set up more complex simulations: https://meep.readthedocs.io/en/latest/





User

1 / 2

Good! Let me tell you more things to make the problem clear. Our operating wavelength should be 0.98. And there should be 50*50 holes with initial radius 0.1 in the photonic crystal layer. Considering these additions and help me modify our code.
ChatGPT

2 / 2

Alright, let's define the photonic crystal layer using a grid of cylindrical holes in the 3D structure. The hole's radius is 0.1 and the lattice constant (i.e., distance from one hole to the next) will be defined such that we have 50x50 holes within the 10x10 simulation cell. The holes will have air refractive index (n=1), and will be arranged in a square lattice in the x-y plane.

Please note that this is a simplified model and doesn't consider edge effects or boundary conditions. This basic example also does not include the necessary sources or detectors to actually simulate the laser, which are complex to set up and require additional considerations.

Here's the modified code:

python
Copy code
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the 3D cell size
cell_size = mp.Vector3(10, 10, z_total)

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Create a list to store the hole definitions
holes = []

# Define the hole lattice constant based on the cell size and number of holes
lattice_constant = cell_size.x / n_holes

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(mp.inf, mp.inf, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the 3D sources
sources = [mp.Source(mp.ContinuousSource(frequency=frequency, width=20),
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(1.0)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Run the simulation
sim.run(until=200)
This is a more advanced Meep setup, so I'd recommend thoroughly going through the Meep documentation and tutorials to understand it in detail: https://meep.readthedocs.io/en/latest/





User
Well done. Do you think our code is enough for the realization of the simulation function?
ChatGPT
This code sets up a basic framework for a simulation of a photonic crystal surface-emitting laser (PCSEL) with a defined 3D layered structure and a square lattice of air holes in the photonic crystal layer. It includes the substrate, cladding layers, active layer, photonic crystal layer, and sources with a specified frequency.

However, please note that this script does not account for several important aspects:

Gain Medium: In a real laser, the active layer would include a gain medium, such as a semiconductor quantum well, that amplifies the light. Meep can simulate gain media, but it requires additional steps that are not included in this script.

Boundary Conditions: This script assumes perfectly periodic boundary conditions along the x and y axes, which may not be accurate for a real device, especially at the edges of the photonic crystal.

Detectors or Monitors: In order to extract useful information from the simulation, you would need to add detectors or monitors at the locations where you are interested in observing the field.

Refinement and Optimization: This code does not include any optimization routine. In practice, you would need to adjust the parameters of the structure (such as the hole radius, lattice constant, and layer thicknesses) and possibly the source characteristics to achieve the desired laser performance. This could be done manually, or by using an optimization algorithm such as those provided by the inverse design methods mentioned earlier.

Computation Resources: A full 3D simulation of a photonic crystal laser with high resolution can be computationally intensive and might require a high-performance computing cluster, especially for simulations over long periods of time or for parameter sweeps or optimizations.

In short, while the code provides a starting point for your PCSEL simulation, you would need to add and adjust many details to model a specific device and to get accurate and useful results. As always, it is recommended to start with simpler models and gradually add complexity, testing at each step to make sure the results make sense. Reading through the Meep documentation and examples, and consulting with experts in computational photonics, would be very helpful in this process.





User

2 / 2

Well. Let us solve the problem of detectors/monitors. Let our optimized target be Q factors, resonance wavelength, emitted power, mode volume and divergence angle. Based on our previous code, can you add a monitor for calculating these values?
ChatGPT

2 / 2

In a photonic crystal laser simulation like this, many of the performance metrics you mentioned are not straightforward to compute directly from a single simulation run. These metrics often involve complex post-processing, multiple simulation runs, or analytical calculations.

That being said, here's a basic outline of how you might compute or approximate some of these quantities in Meep. Note that this won't be a complete solution, but it should help you get started:

1. Q factors and resonance wavelengths:

In Meep, you can calculate the Q factor and resonant frequency of a mode by running a "harminv" (harmonic inversion) analysis. Harminv works by fitting a damped sinusoid to the time-domain field data and determining the decay rate and oscillation frequency. However, this method requires that the simulation be excited by a broadband source, not a single-frequency source. So you'll need to adjust your source to cover a range of frequencies around the frequency of interest. Here's an example of how you might do this:

python
Copy code
# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Run the simulation and perform the Harminv analysis
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)
After the simulation runs, you can access the Q factors and frequencies from the Harminv data:

python
Copy code
for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")
2. Emitted power:

You can compute the emitted power by integrating the Poynting vector over a surface enclosing the source. This requires a dft_flux object in Meep. Here's a basic example:

python
Copy code
# Define a box around the source
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(10, 10, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)
3. Mode volume:

The mode volume isn't something that's generally computed directly in a FDTD simulation like this. It might be more appropriate to use an eigenmode solver to compute the mode profiles, and then integrate the energy density over space to get the mode volume. Meep has eigenmode solver capabilities, but this would be a more complex calculation.

4. Divergence angle:

The divergence angle is also a complex metric to compute directly from an FDTD simulation. One possible approach is to monitor the far-field pattern of the emission, and then compute the divergence from that pattern.

Again, these are just basic examples and may not work directly in your case. You'll need to understand the theory behind each of these metrics, and possibly consult the Meep documentation or experts in computational photonics to accurately compute these metrics for your specific device.





User
Good job! Here I connected all the code together, and it should be look like this:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the 3D cell size
cell_size = mp.Vector3(10, 10, z_total)

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Create a list to store the hole definitions
holes = []

# Define the hole lattice constant based on the cell size and number of holes
lattice_constant = cell_size.x / n_holes

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(mp.inf, mp.inf, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the 3D sources
sources = [mp.Source(mp.ContinuousSource(frequency=frequency, width=20),
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(1.0)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Run the simulation
sim.run(until=200)

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Run the simulation and perform the Harminv analysis
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

# Define a box around the source
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(10, 10, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)
ChatGPT
Your combined code looks good overall, and it should create a 3D photonic crystal surface emitting laser (PCSEL) design and start the initial analysis. However, there are a few potential issues that you should be aware of:

You're creating the sources twice. It seems like you're trying to first simulate with a continuous-wave source, then run a second simulation with a broadband Gaussian source for the Harminv analysis. Instead, you might want to use just the Gaussian source, as it covers a range of frequencies and is therefore suitable for both the initial simulation and the Harminv analysis.

The sequence of sim.run commands might not behave as expected. The Meep simulation object keeps running until you tell it to stop or it reaches the specified run time. If you want to run multiple simulations, you should either call sim.reset_meep to clear the fields and start a new simulation, or use the until_after_sources argument to continue the simulation after the sources have turned off.

The mp.after_sources(*harminv_regions) command tells Meep to start the Harminv analysis after the sources have turned off. However, since you're using a mp.GaussianSource, the sources never really turn off completely. Instead, they just become very weak. You might need to adjust the until_after_sources time to ensure that the sources have decayed enough for the Harminv analysis to be accurate.

The flux computation will not return the correct value since you need to add it before running the simulation, not after.

As for the output power, you may want to monitor it near the PCSEL's surface rather than in a box around the source.

Remember, these are complex simulations and could take a significant amount of computational resources and time to run. Always start with lower-resolution, shorter simulations to debug and validate your setup before moving on to the final high-resolution, long-duration simulations.

Good luck with your project, and feel free to ask if you have any more questions!





User
Thank you for your suggestion, please help me modify the code and eliminate these five pieces of mistakes.
ChatGPT
Sure, here is the corrected version of the code:

python
Copy code
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the 3D cell size
cell_size = mp.Vector3(10, 10, z_total)

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Create a list to store the hole definitions
holes = []

# Define the hole lattice constant based on the cell size and number of holes
lattice_constant = cell_size.x / n_holes

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(mp.inf, mp.inf, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(1.0)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(10, 10, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
This updated code now performs the Harminv analysis in a separate simulation run, after resetting the fields from the first simulation. The flux computation is also placed before the simulation run to ensure accurate results. The simulation setup and parameters remain the same for both simulation runs.

Remember that these simulations can be computationally intensive and may require powerful hardware or long run times to complete. Always test your simulations with lower resolution or shorter run times to ensure everything is working as expected. Good luck with your project!





User
Thank you. I run the code you gave me. But this error happens while running, please help me fix it: "RuntimeError: meep: invalid boundary absorbers for this grid_volume"

ChatGPT
The RuntimeError you are encountering is likely due to an incorrect definition of the Perfectly Matched Layer (PML). The PML boundary condition might not match with the geometry of your simulation domain, which leads to an error when initializing the simulation.

By default, MEEP puts the PML layers on all boundaries of the cell. However, when you define a cell that has infinite size along some directions, you cannot put PMLs along those infinite directions. Therefore, if the dimensions of your geometry (in the Block objects) are set to infinity along some axis, the PML should only be applied to the finite dimensions.

In your case, it seems like your device is infinitely extended in the x and y directions (mp.inf), and only limited in the z direction. Therefore, you should apply the PML layers only in the z direction. To specify this, you can modify the mp.PML command as follows:

python
Copy code
pml_layers = [mp.PML(1.0, direction=mp.Z)]
This will create a PML layer only in the z direction of 1 unit thickness. Adjust this thickness based on your actual simulation domain to ensure that it is suitable for absorbing outgoing waves. Make sure to test different PML thicknesses to find the optimal one for your specific situation.





User
Thank you, I made some modification to our code as you told me, please help me check again:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the 3D cell size
cell_size = mp.Vector3(10, 10, z_total)

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Create a list to store the hole definitions
holes = []

# Define the hole lattice constant based on the cell size and number of holes
lattice_constant = cell_size.x / n_holes

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(mp.inf, mp.inf, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(mp.inf, mp.inf, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(1.0, direction=mp.Z)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(10, 10, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
ChatGPT
Yes, your modification seems fine and the use of the Perfectly Matched Layer (PML) boundary condition looks correct now. But there is still a minor point you need to pay attention to.

The cell size of the simulation is specified to be infinite in the x and y directions and the geometry blocks are also defined to be infinite in these directions. However, for the holes in the photonic crystal layer, they are defined within a finite region in the x and y directions. This discrepancy may cause some unexpected behavior in the simulation.

To be more consistent, it would be better to also define a finite cell size in the x and y directions that matches the extent of the photonic crystal layer.

Here is the part of your code that needs modification:

python
Copy code
# Define the 3D cell size
cell_size = mp.Vector3(cell_size.x, cell_size.y, z_total)  # use finite sizes in x and y
Also, when creating the flux region for monitoring, you need to match the size of the region to the extent of your actual structure. Right now you have it as the same size as your cell, but if you have a structure that does not fill the entire cell (as is the case with your PCSEL structure that is infinite in x and y), you should adjust the size of the flux region accordingly.

python
Copy code
# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(cell_size.x, cell_size.y, z_total))
The rest of your code seems to be fine now and should be able to run without encountering the previous error. But as always, due to the complexity of this type of simulation, it is recommended to carefully inspect and validate the results of your simulation to ensure they are physically meaningful.





User
Sorry, I made some mistakes that misleading you . Here are some additional requirements: Our lattice spacing should be initialized with the value 0.3. And I hope the cell size in the x and y direction could be 50 times lattice spacing. Considering these additions and help me modify our code correspondingly.
ChatGPT
No problem! Here's how you can modify the code according to your new specifications:

python
Copy code
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the 3D cell size
cell_size = mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, z_total)

# Create a list to store the hole definitions
holes = []

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_substrate),  # finite size in x and y
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_n_cladding),  # finite size in x and y
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_active),  # finite size in x and y
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_photonic_crystal),  # finite size in x and y
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_p_cladding),  # finite size in x and y
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(1.0, direction=mp.Z)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(cell_size.x, cell_size.y, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
The cell size and the extent of the geometry blocks are now defined to match the extent of the photonic crystal layer. The flux region also now matches the extent of the structure. These modifications should make the simulation more physically meaningful. Please let me know if there are any other modifications or questions you have.





User
The error "RuntimeError: meep: invalid boundary absorbers for this grid_volume" happens, help me fix it.
ChatGPT
I apologize for the error you are encountering. This error can be due to an inconsistency between the size of the Perfectly Matched Layer (PML) and the simulation region.

In your case, the simulation region extends infinitely along the x and y directions due to the use of mp.inf in defining the geometry. But your PML layers are defined only along the z direction.

You can solve this issue by limiting the extent of your simulation region to a finite size along all directions and adjust the PML definition accordingly.

Here's a modified version of your code:

python
Copy code
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the 3D cell size
cell_size = mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, z_total)

# Create a list to store the hole definitions
holes = []

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(cell_size.x, cell_size.y, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(1.0)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=cell_size)

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
In this version of the code, I defined the mp.PML without specifying a direction, so by default, it applies to all directions. This should prevent the runtime error you were encountering.





User
The error "RuntimeError: meep: invalid boundary absorbers for this grid_volume" happens. Help me fix it.
ChatGPT
I apologize for misunderstanding your problem earlier. The RuntimeError is likely caused by the geometry in the simulation overlapping with the PML boundary layer. When defining the geometry of the simulation, we should leave a buffer zone between the edge of the geometry and the cell boundary, where the PML layers are. This buffer should be at least as large as the PML thickness.

Let's modify your code so that there's a buffer between the edge of your structure and the PML boundary. I'll add a pml_thickness parameter and subtract it from the x and y dimensions of your structures.

python
Copy code
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

# Define the 3D cell size
cell_size = mp.Vector3(n_holes*lattice_constant + 2*pml_thickness, n_holes*lattice_constant + 2*pml_thickness, z_total + 2*pml_thickness)

# Create a list to store the hole definitions
holes = []

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
The main change in this version of the code is that I've added a pml_thickness parameter and then adjusted the cell size and the size of your geometric objects to account for the buffer zone. Now your geometric objects should be within the PML boundary layer, and this should avoid the "invalid boundary absorbers for this grid_volume" error.





User
The error "RuntimeError: meep: Could not determine normal direction for given grid_volume" happens. Help me fix it.
ChatGPT
I apologize for the confusion, this error indicates that Meep couldn't automatically determine the appropriate direction for the PML boundary layer based on your simulation's grid volume. This could be due to a mismatch between the dimensions of your grid volume and the direction specified for the PML layer.

In your case, you are using a 3D simulation volume, but you're specifying a PML only in the Z direction. Meep is likely getting confused by this.

You can resolve this by setting the PML layer in all directions.

Modify your PML layer declaration as follows:

python
Copy code
# Define the PML layers
pml_layers = [mp.PML(pml_thickness)]
to

python
Copy code
# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y),
              mp.PML(pml_thickness, direction=mp.Z)]
This explicitly defines a PML boundary in all three directions. Your simulation should be able to run with this change.





User

2 / 2

The same error "RuntimeError: meep: Could not determine normal direction for given grid_volume" happens after I modifying our PML layer declaration as you say. Please help me fix it.
ChatGPT
I apologize for the confusion. This error may also be caused by a mismatch between the cell size and the simulation geometry.

Based on your code, I see you have defined the 3D cell size with respect to the structure along the z direction, and 50 times the lattice spacing along the x and y directions:

python
Copy code
lattice_spacing = 0.3  # Lattice spacing
cell_size = mp.Vector3(50*lattice_spacing, 50*lattice_spacing, z_total)
I notice that for each hole in the photonic crystal layer, you set its center with this line:

python
Copy code
center=mp.Vector3(i*lattice_constant - cell_size.x/2, j*lattice_constant - cell_size.y/2, 0)
The error could arise if any of the holes (or any other object in the geometry) extends beyond the cell boundaries defined by cell_size.

In this case, you can try adding a margin to your cell size to ensure that the cell includes all elements of the geometry:

python
Copy code
margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_spacing + 2*margin, 50*lattice_spacing + 2*margin, z_total + 2*margin)
Also, ensure that your PML layers thickness doesn't exceed the margin. In your code, you set the PML thickness to 1.0, which equals the margin in the example above. If the error still occurs, you can try reducing the PML thickness or increasing the margin until the problem is solved.

Please modify your code accordingly and see if it resolves the issue. If not, let me know and we can investigate further.





User
OK. I have made modification  as you said. This is our code now:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y),
              mp.PML(pml_thickness, direction=mp.Z)]

# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
ChatGPT
Your code looks fine and should work correctly. However, the error "RuntimeError: meep: Could not determine normal direction for given grid_volume" is often thrown due to an issue with the orientation of the Perfectly Matched Layers (PMLs) and the simulation geometry.

The PMLs are currently applied in all three directions (X, Y, Z). However, since you're running a 2D simulation (in XY plane), the Z direction is likely causing the error.

The Z direction might be considered degenerate if your geometry and sources are invariant in this direction, which could lead to this error. Therefore, removing the PML in the Z direction might solve the issue. Let's change the definition of the PML layers to:

python
Copy code
# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]
Also, note that you're defining your holes to be centered at Z = 0, which might be in the middle of your active layer, given your structure's definition. Ensure that this is your intended design.

Please make these modifications and let me know if the problem still persists.





User
OK, I did as you said, but now the code still can not run because the error "RuntimeError: meep: Could not determine normal direction for given grid_volume.". Please check my code twice as following:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, z_total))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")

ChatGPT
I apologize for the confusion. This kind of error usually comes up when there's a problem with the boundaries of the simulation, so it's typically related to the cell size, the PML layers, or the geometry. But your code seems fine regarding these aspects.

After reviewing your code, the issue might come from the definition of the flux region. In your current setup, the flux region encompasses the entire structure along the z-axis. This might cause the problem as the flux region extends beyond the holey structure (the photonic crystal region) and includes areas with different properties (the cladding and substrate).

To solve this issue, try limiting the size of the flux region along the z-axis to the photonic crystal layer thickness. Here's the modified line:

python
Copy code
# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal))
If you need the flux through the entire structure, you can add separate flux monitors for different regions, calculate the flux through each of them, and add up the results. This way, you are monitoring flux through regions with homogenous properties, which could prevent the error.

Remember that the flux box is supposed to capture the relevant part of your simulation - in this case, probably the photonic crystal layer where the interesting part of the field profile lies.

Try this modification and see if the error persists.





User
I am sorry but this error does persist. Our code now is shown as following:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, 0),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)

# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
ChatGPT

2 / 2

I apologize for the confusion. Looking at your code again, I see that your holes are centered at the z=0 plane. However, this is not within your photonic crystal layer. Let's adjust the z-position of the holes to be centered within the photonic crystal layer.

First, calculate the z-position of the photonic crystal layer:

python
Copy code
z_photonic_crystal = -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2
Then, adjust the center of the hole to this z-position:

python
Copy code
# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, z_photonic_crystal),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)
Try making these modifications and run the code again. I hope this will solve the problem you're facing. If not, please let me know, and we can explore further solutions.





User
I am sorry but your suggestion do not help me eliminate the error "RuntimeError: meep: Could not determine normal direction for given grid_volume" . Our code now is shown as following:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

#z-position of the photonic crystal layer
z_photonic_crystal = -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, z_photonic_crystal),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)


# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
ChatGPT
I apologize for the misunderstanding earlier. The error you're encountering "RuntimeError: meep: Could not determine normal direction for given grid_volume" is related to the definition of the FluxRegion. The FluxRegion is used to compute the power flowing through a certain volume, so the size attribute of FluxRegion needs to define the area where you want to calculate the flux.

In your case, you've defined the size of the FluxRegion to be the size of the photonic crystal layer. This definition is creating ambiguity, because it doesn't clearly specify in which direction the flux should be computed (x, y, or z). Meep expects one of the dimensions of the FluxRegion to be zero, to clarify the direction of the flux calculation.

So, if you want to compute the power flowing through the photonic crystal layer in the z direction, you should set the z-dimension of the FluxRegion to zero:

python
Copy code
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, 0))
Or if you want to compute the power flowing in the x or y direction, you should set the respective dimension to zero. I hope this helps! If you have more questions, please, let me know.





User
Thanks a lot. This error has been solved. But there is a new error "AttributeError: 'Simulation' object has no attribute 'harminv_data'". Please help me fix it. Our code is shown as following:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

#z-position of the photonic crystal layer
z_photonic_crystal = -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, z_photonic_crystal),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)


# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, 0))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(*harminv_regions),
        until_after_sources=200)

for mode in sim.harminv_data:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")

ChatGPT
The error is because you're trying to access sim.harminv_data, but there is no such attribute for the Simulation object. The harmonics inversion data needs to be manually captured when the simulation runs.

Here's how you should modify your script to capture the Harminv modes:

python
Copy code
# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
harminv = sim.run(mp.after_sources(*harminv_regions),
                  until_after_sources=200)

# Print the modes
for mode in harminv.modes:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
Note that sim.run(mp.after_sources(*harminv_regions)) returns a Harminv object which has a modes attribute containing the modes found by the harmonic inversion analysis.

Please try this modification to your code and let me know if you encounter any more issues!





User
Thanks, but it still has error after I made modifications. The error is "AttributeError: 'NoneType' object has no attribute 'modes'", and our code is shown as following:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

#z-position of the photonic crystal layer
z_photonic_crystal = -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, z_photonic_crystal),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)


# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, 0))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv_regions = [mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency)] # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
harminv = sim.run(mp.after_sources(*harminv_regions),
                  until_after_sources=200)

# Print the modes
for mode in harminv.modes:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")


ChatGPT
I apologize for the confusion. The sim.run() method doesn't return a Harminv object as I mistakenly suggested. Instead, the Harminv object(s) is created and added to the simulation in the mp.after_sources(*harminv_regions) line. You can get the Harminv data by accessing the harminv.modes() function, but not through sim.run().

Please modify your code as follows:

python
Copy code
...
# Define where to perform the Harminv analysis
harminv = mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency) # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(harminv),
        until_after_sources=200)

# Print the modes
for mode in harminv.modes():
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
In the code above, harminv is a Harminv object, not a list. If you need to specify multiple Harminv regions, you would need to handle each region separately. Each Harminv object will independently find the modes at its specified location.





User
Thank you. I have made modifications as you said. But a new error "TypeError: 'list' object is not callable" raised. Please help me fix it. Our code is shown as follows:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

#z-position of the photonic crystal layer
z_photonic_crystal = -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, z_photonic_crystal),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)


# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, 0))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv = mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency) # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(harminv),
        until_after_sources=200)

# Print the modes
for mode in harminv.modes():
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")

ChatGPT
I apologize for the confusion. The modes attribute of the Harminv class is a list, not a method, so you should not call it with parentheses. You can iterate over the modes attribute directly. Here is how you should modify your code:

python
Copy code
...
# Print the modes
for mode in harminv.modes:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")
In the code above, harminv.modes is a list of HarminvMode objects, each of which has freq and Q attributes representing the frequency and Q factor of the mode, respectively.





User
I have made the modification accordingly and our code finally run successfully. But why the Q factor I get is negative? Our code is shown as follows:
import meep as mp
import numpy as np

# Define the layer thicknesses
t_substrate = 0.2
t_n_cladding = 0.3
t_active = 0.5
t_photonic_crystal = 0.3
t_p_cladding = 0.3

# Define the layer refractive indices
n_substrate = 3.0
n_n_cladding = 3.2
n_active = 3.4
n_photonic_crystal = 3.0
n_p_cladding = 3.2

# Total structure size along z
z_total = t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding

# Define the hole parameters
hole_radius = 0.1
n_holes = 50  # number of holes in x and y directions

# Define the hole lattice constant
lattice_constant = 0.3

# Define the PML thickness
pml_thickness = 1.0

margin = 1.0  # For example, add a margin of 1.0 in each direction
cell_size = mp.Vector3(50*lattice_constant + 2*margin, 50*lattice_constant + 2*margin, z_total + 2*margin)


# Create a list to store the hole definitions
holes = []

#z-position of the photonic crystal layer
z_photonic_crystal = -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2

# Create the holes
for i in range(n_holes):
    for j in range(n_holes):
        # Create a cylindrical hole at this position
        hole = mp.Cylinder(radius=hole_radius, height=t_photonic_crystal,
                           center=mp.Vector3(i*lattice_constant - n_holes*lattice_constant/2, j*lattice_constant - n_holes*lattice_constant/2, z_photonic_crystal),
                           material=mp.Medium(epsilon=1))
        holes.append(hole)


# Define the 3D geometry
geometry = [mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_substrate),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate/2),
                     material=mp.Medium(epsilon=n_substrate**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_n_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2),
                     material=mp.Medium(epsilon=n_n_cladding**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_active),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active/2),
                     material=mp.Medium(epsilon=n_active**2)),
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_photonic_crystal),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal/2),
                     material=mp.Medium(epsilon=n_photonic_crystal**2))] + holes + [
            mp.Block(mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, t_p_cladding),
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding + t_active + t_photonic_crystal + t_p_cladding/2),
                     material=mp.Medium(epsilon=n_p_cladding**2))]

# Define the source parameters
wavelength = 0.98
frequency = 1/wavelength

# Define the broadband source
sources = [mp.Source(mp.GaussianSource(frequency=frequency, fwidth=0.2*frequency), # 20% bandwidth
                     component=mp.Ez,
                     center=mp.Vector3(0, 0, -z_total/2 + t_substrate + t_n_cladding/2))]

# Define the PML layers
pml_layers = [mp.PML(pml_thickness, direction=mp.X),
              mp.PML(pml_thickness, direction=mp.Y)]


# Initialize the simulation
sim = mp.Simulation(cell_size=cell_size,
                    boundary_layers=pml_layers,
                    geometry=geometry,
                    sources=sources,
                    resolution=10)

# Define a box around the source for flux computation
flux_box = mp.FluxRegion(center=mp.Vector3(), size=mp.Vector3(n_holes*lattice_constant, n_holes*lattice_constant, 0))

# Add the DFT flux object to the simulation
flux = sim.add_flux(frequency, 0, 1, flux_box)

# Run the simulation
sim.run(until=200)

# Compute the total emitted power
emitted_power = mp.get_fluxes(flux)

# Define where to perform the Harminv analysis
harminv = mp.Harminv(mp.Ez, mp.Vector3(0,0,0), frequency, 0.1*frequency) # 10% bandwidth

# Reset the fields and use the same geometry and sources for the Harminv analysis
sim.reset_meep()
sim.change_sources(sources)
sim.run(mp.after_sources(harminv),
        until_after_sources=200)

# Print the modes
for mode in harminv.modes:
    print(f"Frequency: {mode.freq} Q factor: {mode.Q}")

print(f"Emitted Power: {emitted_power[0]}")


 
ChatGPT
In MEEP and many other electromagnetism simulations, a negative quality factor Q (or simply negative Q) often signifies an exponentially growing mode, as opposed to an exponentially decaying one (which would be represented by a positive Q).

In the context of resonance, a positive Q value means the resonant system (like a resonator or an oscillator) will decay over time, which is the usual case. A negative Q means the energy in the resonant system grows over time, which is quite unusual and may suggest some gain medium is present (like in lasers), or it could indicate some instability or numerical artifact in the simulation.

So, in your case, if you're not expecting any gain (like you would in a laser cavity), then a negative Q could indicate that there's an issue with your simulation setup. It could be caused by a variety of things, such as insufficient spatial resolution, too large of a time step, problems with boundary conditions, etc. You might need to revisit your simulation parameters or even the physical model that you're trying to simulate.





User
Thank you. Could you check the code and tell me what is wrong with the code?
ChatGPT
While I'm able to review code for syntax errors and help correct them, it's often more challenging to diagnose conceptual or logic errors that result in unexpected physical behaviors in simulation models, especially without additional context about your model. It can be dependent on many different factors such as the geometry, the boundary conditions, the material properties, and even the stability of the simulation algorithms.

However, based on the information available in your code, I can provide some suggestions that you might consider:

Check Your Geometry and Material Parameters: Verify that all the dimensions and refractive indices of the layers and holes are correctly defined, as these values can directly influence the simulated behavior of your system.

Refine Your Simulation Parameters: You could try refining your spatial resolution or adjusting your time steps to see if the negative Q factors still persist.

Boundary Conditions: Check your boundary conditions and make sure they are defined correctly. For instance, you are using Perfectly Matched Layers (PMLs) only in the X and Y directions. If there's any significant wave propagation along the Z direction that isn't perfectly aligned with the layer interfaces, you may want to consider adding a PML in the Z direction as well.

Source Definition: You could also check your source parameters. If the source frequency is very close to the resonant frequency of the system, it could cause instabilities. If the problem persists, you might want to move the source location outside the structure, away from any resonant elements.

Harminv Parameter: Make sure the Harminv parameters are correctly set up. Particularly, check that the bandwidth is appropriate for the frequencies you're interested in.

Please remember that these are just suggestions, and the actual reason might be something completely different. Debugging simulations can often be a complex task that requires a deep understanding of the physical system being modeled and the simulation techniques being used. I recommend going through the MEEP documentation and tutorials thoroughly, as they might give you more insights into the problem.